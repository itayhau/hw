# שאלות אמריקאיות - ניהול זיכרון, תכנות מקבילי ותכנות מונחה עצמים בפייתון

## ניהול זיכרון ו-GC

### שאלה 1
מה מודדת הפונקציה `sys.getsizeof` בפייתון?
- את מספר ההפניות לאובייקט
- את גודל האובייקט בזיכרון בבייטים
- את זמן החיים של האובייקט
- את מספר התכונות (attributes) של האובייקט

### שאלה 2
מה קורה כאשר מספר ההפניות (references) לאובייקט בפייתון מגיע לאפס?
- האובייקט עובר לדור הבא ב-GC
- האובייקט נשמר במטמון (cache) זמני
- האובייקט משוחרר מהזיכרון באופן מיידי
- האובייקט מועבר למנגנון Mark and Sweep

### שאלה 3
מהי שיטת ה-GC שמשתמשת בהנחה שרוב האובייקטים חיים לזמן קצר?
- א: Reference Counting
- ב: Generational GC
- ג: Mark and Sweep
- ד: Compaction GC

### שאלה 4
מהי בעיית ה-Cycle References בהקשר של ניהול זיכרון בפייתון?
- אובייקטים גדולים מדי שתופסים יותר מדי זיכרון
- חוסר התאמה בין מערכת ההפעלה למנגנון ה-GC
- אובייקטים המפנים אחד לשני במעגל שאינם משוחררים באמצעות Reference Counting בלבד
- סגמנטציה של הזיכרון במהלך ריצת התוכנית

### שאלה 5
מהו Weak Reference בפייתון?
- הפניה למשתנה גלובלי בלבד
- הפניה שאינה מגדילה את מונה ההפניות לאובייקט
- הפניה שמתבצעת רק בזמן ריצה של פונקציה
- הפניה למשתנה שעדיין לא הוגדר

### שאלה 6
מהי דליפת זיכרון (Memory Leak) בפייתון?
- מצב בו זיכרון שאינו בשימוש אינו משוחרר לאורך זמן
- שימוש בזיכרון וירטואלי במקום זיכרון פיזי
- שימוש מוגזם במשתנים גלובליים בתוכנית
- גישה לזיכרון שכבר שוחרר על ידי מנגנון ה-GC

## מנגנוני תכנות מקבילי

### שאלה 7
מהו ה-GIL (Global Interpreter Lock) בפייתון ומה השפעתו על multithreading?
- מנגנון שמאפשר ריצה מקבילית יעילה של קוד פייתון
- מנעול שמגביל את ריצת הקוד כך שרק thread אחד יכול לבצע קוד Python בזמן נתון
- כלי לניהול זיכרון משותף בין threads
- אמצעי אבטחה שמונע התקפות על תהליכי Python

### שאלה 8
כיצד ניתן להתגבר על מגבלת ה-GIL בפייתון כאשר רוצים לנצל מספר ליבות CPU?
- הגדלת מספר ה-threads בתוכנית
- שימוש ב-multiprocessing במקום multithreading
- פיתוח קוד מונחה אירועים (event-driven)
- שימוש ב-async/await בלבד

### שאלה 9
מהו race condition בתכנות מקבילי?
- תחרות בין תהליכים על משאבי מעבד
- תקלה בזיכרון המטמון (cache)
- מצב בו התוצאה תלויה בסדר או בעיתוי הביצוע של פעולות מקביליות
- אלגוריתם לתזמון threads על ידי מערכת ההפעלה

### שאלה 10
מהי המטרה העיקרית של שימוש ב-Lock במודול Threading של פייתון?
- הגברת מהירות הביצוע של thread
- מניעת גישה בו-זמנית למשאב משותף
- הקצאת זיכרון נפרד לכל thread
- העברת thread למצב של השהייה (sleep)

## תכנות מונחה עצמים (OOP)

### שאלה 11
מה תפקידה של המתודה `__init__` במחלקה בפייתון?
- להגדיר את המחלקה כסטטית
- לאתחל את המופע (instance) של המחלקה ולקבוע את מצבו ההתחלתי
- לסיים את חיי האובייקט כשהוא יוצא מטווח
- להפוך מתודות רגילות למתודות סטטיות

### שאלה 12
האם פייתון תומך בירושה מרובה (multiple inheritance)?
- כן, פייתון תומך באופן מלא בירושה מרובה
- לא, פייתון תומך רק בירושה יחידה (single inheritance)
- כן, אבל רק עם מחלקות מופשטות (abstract classes)
- לא, פייתון מציע רק interfaces במקום ירושה מרובה

### שאלה 13
מה ההבדל העיקרי בין Class Method ל-Instance Method בפייתון?
- א: Class Method יכולה לשנות את המחלקה, Instance Method יכולה לשנות רק את האובייקט
- ב: Class Method מקבלת את המחלקה כפרמטר ראשון (cls), בעוד Instance Method מקבלת את האובייקט כפרמטר ראשון (self)
- ג: Class Method לא יכולה לקרוא למשתני אובייקט, בעוד Instance Method יכולה לקרוא הן למשתני מחלקה והן למשתני אובייקט
- ד: Instance Method חייבת להיות מוגדרת עם המעטר @instance, בעוד Class Method מוגדרת עם המעטר @classmethod

### שאלה 14
מהי המטרה העיקרית של Static Method בפייתון ומתי נשתמש בה?
- לביצוע פעולות שאינן תלויות במצב האובייקט או המחלקה
- לגישה ושינוי של משתני מחלקה בלבד
- ליצירת מופעים חדשים של המחלקה
- להגדרת קבועים בתוך המחלקה

### שאלה 15
מהי המטרה העיקרית של property decorator (@property) בפייתון?
- לשפר את ביצועי הגישה למשתני המחלקה
- לאפשר גישה למשתנים פרטיים מחוץ למחלקה
- לאפשר גישה למשתני מחלקה כאילו הם תכונות רגילות, תוך הוספת לוגיקה בעת קריאה וכתיבה
- להפוך מתודות רגילות לסטטיות

### שאלה 16
מהי מטרת הפונקציה `super` בפייתון?
- לאפשר גישה לאובייקט בעל ביצועים משופרים
- לגשת למתודות וערכים של מחלקת הבסיס (מחלקת האב) בירושה
- ליצור מופע חדש של המחלקה הנוכחית
- להריץ קוד במהירות גבוהה יותר

### שאלה 17
האם חובה לממש מתודה אבסטרקטית (מתודה שהוגדרה עם המעטר @abstractmethod) במחלקה שיורשת ממחלקה אבסטרקטית?
- כן, חייבים לממש את כל המתודות האבסטרקטיות ללא יוצא מן הכלל
- לא, מימוש המתודות האבסטרקטיות הוא אופציונלי תמיד
- כן, אבל רק אם המחלקה היורשת אינה מוגדרת כאבסטרקטית בעצמה
- לא, מספיק להגדיר את אותה מתודה עם @abstractmethod גם במחלקה היורשת

### שאלה 18
מה התפקיד העיקרי של מערכת Logging (כמו מודול logging בפייתון) בפיתוח תוכנה?
- להאט את ריצת התוכנית כדי למנוע שגיאות
- לנהל ולשמור מידע על התנהגות התוכנית בזמן ריצה, לצורכי ניטור, איתור באגים ותחזוקה
- לבדוק באופן אוטומטי את התקינות של הקוד
- לקשר בין שכבות שונות של האפליקציה

### שאלה 19
מהו עקרון ה-Encapsulation (הכמסה) בתכנות מונחה עצמים?
- טכניקה להגדלת מהירות הביצוע של התוכנית
- עקרון לפיו נתונים ופעולות על הנתונים נארזים יחד ביחידה אחת, תוך הסתרת המימוש הפנימי ומתן גישה מבוקרת
- שיטה להפחתת שימוש בזיכרון
- טכניקה לשכפול אובייקטים בצורה יעילה

### שאלה 20
מהו עקרון הפולימורפיזם (Polymorphism) בתכנות מונחה עצמים?
- עקרון המאפשר למחלקה לרשת תכונות ומתודות ממחלקות אחרות
- עקרון המאפשר לאותה פעולה (מתודה) להתנהג באופן שונה כאשר היא מיושמת במחלקות שונות
- עקרון המאפשר להסתיר נתונים ולחשוף רק את הממשק הנדרש למשתמש
- עקרון המאפשר יצירת מופעים רבים של אותה מחלקה

### שאלה 21
מהו Override (דריסה) במונחי תכנות מונחה עצמים בפייתון?
- פעולה שמוחקת לחלוטין את המתודה של מחלקת האב
- מנגנון שמאפשר למחלקה בת להגדיר מחדש את המימוש של מתודה שירשה ממחלקת האב
- שיטה להסתרת משתנים פרטיים במחלקה
- טכניקה לאילוץ שימוש במתודות מסוימות בלבד

### שאלה 22
מהי מחלקה אבסטרקטית בפייתון ומה מטרתה העיקרית?
- מחלקה שניתן ליצור ממנה מופעים רבים במהירות גבוהה
- מחלקה שמשמשת כתבנית למחלקות אחרות, מכילה מתודות אבסטרקטיות ולא ניתן ליצור ממנה מופע ישירות
- מחלקה שנוצרת אוטומטית על ידי המהדר בזמן ריצה
- מחלקה שקיימת רק בשלב התכנון ונמחקת בזמן הקומפילציה

### שאלה 23
בפייתון, ממי כל המחלקות יורשות באופן אוטומטי אם לא צוין אחרת?
- א: `BaseClass`
- ב: `object`
- ג: `Object`
- ד: `root`

### שאלה 24
מה תפקידו של ה-hash value בפייתון ואיזו פעולה משמשת לחישובו?
- לשמור את כתובת הזיכרון של האובייקט, משתמשים בפעולה `address()`
- לשמש כמזהה ייחודי לאובייקטים ולאפשר שימוש יעיל במבני נתונים כמו סטים ומילונים, משתמשים בפונקציה `hash()`
- לחשב את גודל האובייקט בזיכרון, משתמשים בפונקציה `sizeof()`
- לאבטח את האובייקט מפני שינויים, משתמשים בפונקציה `secure()`

### שאלה 25
מה יקרה אם שני אובייקטים הם שווים על פי מתודת `__eq__` אבל יש להם ערכי `__hash__` שונים?
- זה תקין, פייתון יתעלם מערכי ה-hash כאשר הוא מזהה ש-`__eq__` מחזיר `True`
- המערכת תזרוק TypeError בכל פעם שמנסים להשוות בין האובייקטים
- האובייקטים יוכלו להיות במיקומים שונים באותו מילון או סט, מה שיוביל להתנהגות בלתי צפויה
- פייתון יאלץ את ה-hash של שני האובייקטים להיות זהה על מנת לשמור על עקביות
