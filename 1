# שאלות אמריקאיות - ניהול זיכרון, מנגנוני תכנות מקבילי ו-SQLAlchemy

## ניהול זיכרון ו-GC

### שאלה 1
מה מודדת הפונקציה `sys.getsizeof()` בפייתון?
- את מספר ההפניות לאובייקט
- **את גודל האובייקט בזיכרון בבייטים**
- את זמן החיים של האובייקט
- את מספר התכונות (attributes) של האובייקט

### שאלה 2
מהו המנגנון העיקרי לניהול זיכרון בפייתון?
- **Reference Counting**
- Mark and Sweep
- Compaction
- Manual Memory Management

### שאלה 3
מהי שיטת ה-GC שמשתמשת בהנחה שרוב האובייקטים חיים לזמן קצר?
- Reference Counting
- **Generational GC**
- Mark and Sweep
- Compaction GC

### שאלה 4
מהי בעיית ה-Cycle References?
- אובייקטים גדולים מדי לזיכרון
- חוסר התאמה בין מערכת ההפעלה לפייתון
- **אובייקטים המפנים אחד לשני במעגל שלא נמחקים ע"י reference counting**
- סגמנטציה של הזיכרון

### שאלה 5
מהו Weak Reference בפייתון?
- הפניה למשתנה גלובלי
- **הפניה שאינה מגדילה את מונה ההפניות לאובייקט**
- הפניה שמתבצעת רק בזמן ריצה
- הפניה למשתנה שלא הוגדר

### שאלה 6
מה קורה כאשר מספר ההפניות לאובייקט מגיע לאפס?
- האובייקט עובר לדור הבא ב-GC
- האובייקט נשמר במטמון (cache)
- **האובייקט משוחרר מהזיכרון**
- האובייקט הופך להיות weak reference

### שאלה 7
מהי דליפת זיכרון (Memory Leak) בפייתון?
- **מצב בו זיכרון שאינו בשימוש אינו משוחרר לאורך זמן**
- שימוש בזיכרון וירטואלי במקום זיכרון פיזי
- שימוש מוגזם ב-global variables
- גישה לזיכרון שכבר שוחרר

### שאלה 8
מדוע נוצרות בעיות Memory Leaks בפייתון למרות מנגנון ה-GC?
- כי פייתון אינו תומך בשחרור זיכרון אוטומטי
- **בגלל הפניות מעגליות שלא נוהלו נכון או אובייקטים שנשמרים בקולקציות**
- בגלל שהמתכנת חייב לקרוא ידנית ל-`free()`
- רק בגלל באגים במימוש של פייתון

## מנגנוני תכנות מקבילי

### שאלה 9
מהו ההבדל העיקרי בין Thread ל-Process?
- Threads רצים תמיד מהר יותר מ-Processes
- **Threads חולקים זיכרון באותו תהליך, בעוד Processes מבודדים בזיכרון נפרד**
- Processes תמיד צורכים פחות משאבים מ-Threads
- Threads רצים על CPU אחד, Processes רצים על CPUs שונים

### שאלה 10
מהו ה-GIL בפייתון?
- מנגנון שמאפשר ריצה מקבילית של קוד פייתון
- כלי לניהול זיכרון
- **מנעול שמגביל ריצה מקבילית של קוד פייתון במקביל באותו תהליך**
- שכבת אבטחה למניעת גישה לא מורשית

### שאלה 11
כיצד ניתן להתגבר על מגבלת ה-GIL בפייתון?
- שימוש ב-multithreading בלבד
- **שימוש ב-multiprocessing**
- שימוש ב-async/await
- לא ניתן להתגבר על המגבלה

### שאלה 12
מהו race condition?
- תחרות בין תהליכים על משאבי מעבד
- תקלה בזיכרון המטמון
- **מצב בו התוצאה תלויה בסדר הביצוע של פעולות מקביליות**
- אלגוריתם לתזמון threads

### שאלה 13
מהי המטרה העיקרית של Lock בתכנות מקבילי?
- הגברת מהירות הביצוע
- **מניעת גישה בו-זמנית למשאב משותף**
- הקצאת זיכרון לתהליכים
- הקפצת קוד למעבד אחר

### שאלה 14
כיצד מגדירים Thread בפייתון שיריץ פונקציה מסוימת?
- **`Thread(target=func)`**
- `Thread.set_function(func)`
- `Thread.execute(func)`
- `Thread >> func`

### שאלה 15
מהו Singleton בהקשר של תכנות מקבילי?
- תהליך שרץ בעדיפות גבוהה
- **תבנית עיצוב המבטיחה שקיימת רק מופע אחד של מחלקה בכל התוכנית**
- Thread שרץ באופן מבודד
- מנגנון לניהול מספר גדול של תהליכים

### שאלה 16
מהי השיטה המומלצת לשיתוף מידע בין מספר Processes?
- שימוש במשתנים גלובליים
- הפעלת GIL באופן ידני
- **שימוש ב-Queue או ב-Pipe**
- שימוש ב-Global Dictionary

## SQLAlchemy

### שאלה 17
מהו ORM בהקשר של SQLAlchemy?
- Object Reference Model
- **Object-Relational Mapping**
- Online Resource Management
- Optimized Result Manager

### שאלה 18
מה מאפשר ORM למפתחים?
- לכתוב שאילתות SQL מהירות יותר
- **לעבוד עם בסיסי נתונים באמצעות אובייקטים במקום SQL ישיר**
- לייצא נתונים ישירות לקבצי CSV
- להתחבר למספר רב יותר של בסיסי נתונים

### שאלה 19
איזו פעולה מבצע הקוד הבא ב-SQLAlchemy?
```python
session.add(new_user)
session.commit()
